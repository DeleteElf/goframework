# 风格指南
## Go 风格指南
https://google.github.io/styleguide/go/guide

**注意：** 这是概述 Google Go 风格的一系列文档的一部分。本文档是规范性和 权威性的。有关更多信息，请参阅概述。
### 风格原则
有一些总体原则总结了如何思考编写可读的 Go 代码。以下是可读代码的属性，按重要性排序：
1. **清晰度：** 代码的目的和原理对读者来说很清楚。
2. **简单：** 代码以最简单的方式实现其目标。
3. **简洁：** 代码具有较高的信噪比。
4. **可维护性：** 代码编写得易于维护。
5. **一致性：** 代码与更广泛的 Google 代码库一致。
### 明晰
可读性的核心目标是编写读者能够清晰理解的代码。

清晰度主要通过有效的命名、有用的注释和高效的代码组织来实现。

清晰度应从读者的角度而不是代码作者的角度来看待。代码易读比易写更重要。代码清晰度有两个不同的方面：
* 代码实际上在做什么？
* 为什么代码会执行其所做的事情？
#### 代码实际上在做什么？
Go 的设计使得代码的作用应该相对直观。在不确定的情况下，或者读者可能需要先验知识才能理解代码的情况下，值得花时间让代码的用途对未来的读者更清晰。例如，它可能有助于：
* 使用更具描述性的变量名
* 添加其他评论
* 使用空格和注释分隔代码
* 将代码重构为单独的函数/方法，使其更加模块化

这里没有一刀切的方法，但在开发 Go 代码时优先考虑清晰度非常重要。
#### 为什么代码会执行其所做的事情？
代码的原理通常可以通过变量、函数、方法或包的名称充分传达。如果没有，则必须添加注释。当代码包含读者可能不熟悉的细微差别时，“为什么？”尤其重要，例如：
* 语言中的一个细微差别，例如，闭包将捕获循环变量，但闭包距离很多行
* 业务逻辑的细微差别，例如，访问控制检查需要区分实际用户和冒充用户的人

API 可能需要小心谨慎才能正确使用。例如，一段代码可能因性能原因而错综复杂且难以理解，或者复杂的数学运算序列可能会以意想不到的方式使用类型转换。在这些情况以及更多情况下，重要的是随附的注释和文档应解释这些方面，以便未来的维护者不会犯错，并且读者无需对其进行逆向工程即可理解代码。

还要注意的是，某些旨在提供清晰度的尝试（例如添加额外的注释）实际上可能会使代码的目的变得模糊，因为它们会增加混乱、重申代码已经说了什么、与代码相矛盾或增加维护负担以保持注释的更新。让代码自己说话（例如，通过使符号名称本身具有自描述性）而不是添加多余的注释。注释通常最好解释为什么这样做，而不是代码在做什么。

Google 代码库在很大程度上是统一且一致的。通常情况下，一些代码脱颖而出（例如，通过使用不熟悉的模式）是有充分理由的，通常是为了提高性能。保持这一特性很重要，这样读者在阅读新代码时就可以清楚地知道应该把注意力集中在哪里。

标准库包含许多此原则的实际示例。其中包括：
* 维护者在 中发表评论 package sort。
* 同一个包中具有良好的 可运行示例，这对用户（它们 显示在 godoc 中）和维护者（它们作为测试的一部分运行）都有好处。
* strings.Cut仅有四行代码，但它们提高了 调用站点的清晰度和正确性。
### 简单
对于使用、阅读和维护它的人来说，您的 Go 代码应该很简单。

Go 代码应该以最简单的方式编写，以实现其目标，无论是在行为还是性能方面。在 Google Go 代码库中，简单的代码：
* 从上到下易于阅读
* 不假设你已经知道它在做什么
* 不假设你能记住前面所有的代码
* 没有不必要的抽象层次
* 没有能引起人们注意的平凡名字
* 让读者清楚地了解价值观和决策的传播
* 有注释来解释代码为什么这样做而不是做什么，以避免将来出现偏差
* 有独立的文档
* 有有用的错误和有用的测试失败
* 可能经常与“聪明”代码互相排斥

代码简单性和 API 使用简单性之间可能会出现权衡。例如，让代码更复杂一些可能是值得的，这样 API 的最终用户就可以更轻松地正确调用 API。相反，将一些额外的工作留给 API 的最终用户也可能是值得的，这样代码仍然简单易懂。

当代码需要复杂性时，应该刻意增加复杂性。如果需要额外的性能，或者某个库或服务有多个不同的客户，这通常是必要的。复杂性可能是合理的，但它应该附带文档，以便客户和未来的维护者能够理解和驾驭复杂性。这应该辅以测试和示例来演示其正确的用法，特别是如果存在“简单”和“复杂”两种使用代码的方式。

这一原则并不意味着不能或不应该用 Go 编写复杂代码，或者不允许 Go 代码复杂。我们努力避免不必要的复杂性，以便当复杂性出现时，它表明相关代码需要小心理解和维护。理想情况下，应该附上注释，解释理由并确定应采取的措施。这通常出现在优化代码以提高性能时；这样做通常需要更复杂的方法，例如预分配缓冲区并在 goroutine 生命周期内重复使用它。当维护者看到这一点时，这应该是相关代码对性能至关重要的线索，这应该会影响未来进行更改时所采取的措施。另一方面，如果不必要地使用这种复杂性，那么对于那些将来需要阅读或更改代码的人来说，这是一种负担。

如果代码的目的应该很简单但实际上却非常复杂，这通常表明需要重新审视实现方式，看看是否有更简单的方法来完成同一件事。
### 最少机制
如果有多种方式来表达同一个想法，则最好使用最标准的工具。复杂的机制经常存在，但不应无缘无故地使用。根据需要添加代码的复杂性很容易，而一旦发现没有必要，就很难消除现有的复杂性。
1. 当足以满足您的用例时，尽量使用核心语言构造（例如通道、切片、映射、循环或结构）。
2. 如果没有，请在标准库中寻找工具（如 HTTP 客户端或模板引擎）。
3. 最后，在引入新的依赖项或创建自己的依赖项之前，请考虑 Google 代码库中是否有足够的核心库。

例如，考虑生产代码，其中包含一个绑定到变量的标志，该变量具有默认值，必须在测试中覆盖该默认值。除非打算测试程序的命令行界面本身（例如，使用os/exec），否则直接覆盖绑定值比使用更简单，因此更可取flag.Set。

类似地，如果一段代码需要集合成员检查，布尔值映射（例如map[string]bool）通常就足够了。仅当需要更复杂的操作而这些操作无法通过映射实现或过于复杂时，才应使用提供集合类型和功能的库。
### 简洁
简洁的Go代码具有较高的信噪比。很容易辨别出相关细节，并且命名和结构会引导读者了解这些细节。

有许多因素可能会在任何时候妨碍最突出的细节浮现：
* 重复代码
* 多余的语法
* 不透明的名称
* 不必要的抽象
* 空格

重复代码尤其会掩盖几乎相同的部分之间的差异，并且需要读者直观地比较相似的代码行才能找到变化。表驱动测试是一个很好的例子，它是一种可以从每次重复的重要细节中简洁地提取出通用代码的机制，但选择将哪些部分包含在表中将影响表格的易懂程度。

在考虑构建代码的多种方式时，值得考虑哪种方式可以使重要的细节最明显。

理解和使用常见的代码结构和习惯用法对于保持较高的信噪比也很重要。例如，下面的代码块在错误处理中非常常见，读者可以快速理解该块的用途。
```go
// Good:
if err := doSomething(); err != nil {
// ...
}
```
如果代码看起来与此非常相似，但有细微的差别，读者可能不会注意到变化。在这种情况下，值得通过添加注释来故意“增强” 错误检查的信号，以引起注意。
```go
// Good:
if err := doSomething(); err == nil { // if NO error
// ...
}
```
### 可维护性
代码编辑的次数比编写的次数多得多。可读性强的代码不仅对试图理解其工作原理的读者有意义，而且对需要更改代码的程序员也有意义。清晰度是关键。

可维护的代码：
* 未来的程序员可以轻松正确修改
* 具有结构化的 API，以便能够优雅地增长
* 清楚自己做出的假设，并选择映射到问题结构而不是代码结构的抽象
* 避免不必要的耦合，不包含未使用的功能
* 拥有全面的测试套件，以确保维护承诺的行为、重要逻辑正确，并且在发生故障时测试提供清晰、可操作的诊断

当使用接口和类型等抽象时，从定义上讲，它们会从使用它们的上下文中删除信息，因此确保它们提供足够的好处非常重要。编辑器和 IDE 可以直接连接到方法定义，并在使用具体类型时显示相应的文档，但在其他情况下只能引用接口定义。接口是一种强大的工具，但需要付出代价，因为维护人员可能需要了解底层实现的具体内容才能正确使用接口，而这必须在接口文档或调用站点中进行解释。

可维护的代码还可以避免将重要细节隐藏在容易被忽视的地方。例如，在以下每一行代码中，单个字符的存在或缺失对于理解该行至关重要：
```go
// Bad:
// The use of = instead of := can change this line completely.
if user, err = db.UserByID(userID); err != nil {
// ...
}
```
```go
// Bad:
// The ! in the middle of this line is very easy to miss.
leap := (year%4 == 0) && (!(year%100 == 0) || (year%400 == 0))
```
这两种说法都没错，但都可以用更明确的方式来写，或者可以附上一条评论，以引起人们对重要行为的注意：
```go
// Good:
u, err := db.UserByID(userID)
if err != nil {
return fmt.Errorf("invalid origin user: %s", err)
}
user = u
```
```go
// Good:
// Gregorian leap years aren't just year%4 == 0.
// See https://en.wikipedia.org/wiki/Leap_year#Algorithm.
var (
leap4   = year%4 == 0
leap100 = year%100 == 0
leap400 = year%400 == 0
)
leap := leap4 && (!leap100 || leap400)
```
同样，隐藏关键逻辑或重要边缘情况的辅助函数可能会使未来的更改无法正确考虑到它。

可预测的名称是可维护代码的另一个特征。软件包的用户或代码片段的维护者应该能够预测给定上下文中的变量、方法或函数的名称。相同概念的函数参数和接收器名称通常应共享相同的名称，这既是为了使文档易于理解，也是为了以最小的开销方便重构代码。

可维护的代码可最大程度地减少其依赖性（包括隐式依赖和显式依赖）。依赖更少的软件包意味着影响行为的代码行更少。避免对内部或未记录的行为的依赖，可降低代码在将来这些行为发生变化时造成维护负担的可能性。

在考虑如何构建或编写代码时，值得花时间思考代码可能随时间演变的方式。如果给定的方法更有利于更轻松、更安全地进行未来更改，那么这通常是一种很好的权衡，即使这意味着设计略微复杂。
### 一致性
一致的代码是指在更广泛的代码库中、在团队或包的上下文中、甚至在单个文件中看起来、感觉和行为都与类似代码相同的代码。

一致性问题不会凌驾于上述任何原则之上，但如果必须打破平局，则打破平局以保持一致性通常是有益的。

包内的一致性通常是一致性中最直接重要的级别。如果同一个问题在整个包中以多种方式解决，或者同一个概念在一个文件中有多个名称，那么这可能会非常令人不快。但是，即使这样也不应该凌驾于文档化样式原则或全局一致性之上。
## 核心指南
这些指南收集了所有 Go 代码都应遵循的 Go 风格最重要的方面。我们希望在可读性得到保证时，人们能够学习并遵循这些原则。这些原则预计不会经常更改，新添加的内容必须满足很高的标准。

以下指南扩展了《Effective Go》中的建议，为整个社区的 Go 代码提供了共同的基线。
### 格式化
所有 Go 源文件都必须符合该gofmt工具输出的格式。此格式由 Google 代码库中的预提交检查强制执行。 生成的代码通常也应格式化（例如，使用 format.Source），因为它也可以在代码搜索中浏览。
### 混合大写
在编写多词名称时，Go 源代码使用MixedCaps或（驼峰式命名）而不是下划线（蛇形命名）。mixedCaps

即使它违反了其他语言的惯例，这也适用。例如，如果常量被导出，则为MaxLength(not MAX_LENGTH)，如果未导出，则为maxLength(not max_length)。

为了选择首字母大写，局部变量被视为未导出。
### 行长度
Go 源代码没有固定的行长。如果觉得一行太长，最好重构而不是拆分。如果行长已经短到可以接受的程度，则应该允许行长。

不要分割线：
* 缩进改变之前（例如函数声明、条件）
* 将长字符串（例如 URL）拆分成多行较短的行
### 命名
命名是一门艺术，而非科学。在 Go 中，名称往往比许多其他语言中的名称要短一些，但适用相同的一般准则。名称应该：
* 使用时不会感到重复
* 考虑上下文
* 不要重复已经清楚的概念

您可以在决策中找到有关命名的更多具体指导。
### 局部一致性
当风格指南对某一特定风格没有任何提及时，作者可以自由选择他们喜欢的风格，除非接近的代码（通常在同一个文件或包中，但有时在团队或项目目录中）对该问题采取了一致的立场。

有效的本地风格考虑示例：
* 使用%s或%v格式化打印错误
* 使用缓冲通道代替互斥锁

无效的本地样式考虑示例：
* 代码行长度限制
* 使用基于断言的测试库

如果本地样式与样式指南不一致，但可读性影响仅限于一个文件，则通常会在代码审查中浮现出来，而一致的修复超出了相关 CL 的范围。此时，提交错误以跟踪修复是合适的。

如果更改会加剧现有的样式偏差、将其暴露在更多 API 界面中、增加存在偏差的文件数量或引入实际错误，则局部一致性不再是违反新代码样式指南的正当理由。在这些情况下，作者应该清理同一 CL 中的现有代码库、在当前 CL 之前进行重构，或者找到至少不会使局部问题恶化的替代方案。